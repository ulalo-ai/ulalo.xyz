"use client"

import React, {useState, useEffect, JSX, useRef} from 'react';
import { Fingerprint, CheckCircle, Loader2, Wallet, XCircle, Camera, Shield, Globe, Eye, AlertCircle } from 'lucide-react';
import { IDKitWidget, ISuccessResult } from '@worldcoin/idkit';

// --- Types ---
interface CaptchaOption {
    color: string;
    hex: string;
}

interface LivenessCheck {
    action: string;
    icon: JSX.Element;
    instruction: string;
    completed: boolean;
}

interface DeviceFingerprint {
    userAgent: string;
    screenResolution: string;
    colorDepth: number;
    timezone: string;
    timezoneOffset: number;
    language: string;
    languages: string[];
    platform: string;
    hardwareConcurrency: number;
    deviceMemory?: number;
    touchSupport: boolean;
    webGLFingerprint?: string;
    webGLVendor?: string;
    webGLRenderer?: string;
    canvas2DFingerprint?: string;
    audioFingerprint?: string;
    fonts: string[];
    plugins: string[];
    cookieEnabled: boolean;
    doNotTrack: string | null;
    localStorage: boolean;
    sessionStorage: boolean;
    indexedDB: boolean;
    cpuClass?: string;
    pixelRatio: number;
    screenOrientation?: string;
    connectionType?: string;
    batteryLevel?: number;
}

// Real Supabase client
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || "https://drxnffnqfmaanmxbvlym.supabase.co";
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRyeG5mZm5xZm1hYW5teGJ2bHltIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg4Nzc0MzQsImV4cCI6MjA1NDQ1MzQzNH0.tPvqhh0NpSjARmstJKdOk61ZGLFKKLrfblAuaxCtwBc";

// World ID Configuration
const WORLD_ID_APP_ID = process.env.NEXT_PUBLIC_WORLDCOIN_APP_ID || "app_385381707e8236bc5ec164e4b7f24f34";
const WORLD_ID_ACTION = process.env.NEXT_PUBLIC_WORLDCOIN_ACTION || "ulalo-passport-claim";

const supabase = createClient(supabaseUrl, supabaseAnonKey);

type Step = 'loading' | 'welcome' | 'world-id' | 'liveness-check' | 'passport-creation' | 'submitting-passport' | 'wallet-form' | 'submitting-wallet' | 'success' | 'already-verified' | 'device-blocked' | 'world-id-used' | 'error';

// --- Utility Functions ---

// Enhanced device fingerprinting with more data points
const generateEnhancedDeviceFingerprint = async (): Promise<DeviceFingerprint> => {
    // Get WebGL fingerprint
    const getWebGLFingerprint = (): { fingerprint?: string; vendor?: string; renderer?: string } => {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return {};

            const debugInfo = (gl as any).getExtension('WEBGL_debug_renderer_info');
            if (!debugInfo) return {};

            const vendor = (gl as any).getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
            const renderer = (gl as any).getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
            return {
                fingerprint: `${vendor}~${renderer}`,
                vendor,
                renderer
            };
        } catch {
            return {};
        }
    };

    // Get Canvas 2D fingerprint
    const getCanvas2DFingerprint = (): string => {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) return '';

            canvas.width = 200;
            canvas.height = 50;

            // Draw test string with various styles
            ctx.textBaseline = 'top';
            ctx.font = '14px "Arial"';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('Ulalo Passport ðŸš€', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Ulalo Passport ðŸš€', 4, 17);

            return canvas.toDataURL();
        } catch {
            return '';
        }
    };

    // Get Audio fingerprint
    const getAudioFingerprint = async (): Promise<string> => {
        try {
            const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
            if (!AudioContext) return '';

            const context = new AudioContext();
            const oscillator = context.createOscillator();
            const analyser = context.createAnalyser();
            const gainNode = context.createGain();
            const scriptProcessor = context.createScriptProcessor(4096, 1, 1);

            oscillator.type = 'triangle';
            oscillator.frequency.value = 10000;
            gainNode.gain.value = 0;

            oscillator.connect(analyser);
            analyser.connect(scriptProcessor);
            scriptProcessor.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.start(0);

            return new Promise((resolve) => {
                setTimeout(() => {
                    const fingerprint = analyser.frequencyBinCount.toString();
                    oscillator.stop();
                    context.close();
                    resolve(fingerprint);
                }, 100);
            });
        } catch {
            return '';
        }
    };

    // Detect installed fonts
    const detectFonts = (): string[] => {
        const baseFonts = ['monospace', 'sans-serif', 'serif'];
        const testFonts = [
            'Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia',
            'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS',
            'Impact', 'Lucida Console', 'Tahoma', 'Helvetica', 'Monaco'
        ];

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) return [];

        const text = 'mmmmmmmmmmlli';
        const textSize = '72px';

        const detectedFonts: string[] = [];

        for (const testFont of testFonts) {
            let detected = false;
            for (const baseFont of baseFonts) {
                ctx.font = `${textSize} ${baseFont}`;
                const baseWidth = ctx.measureText(text).width;

                ctx.font = `${textSize} '${testFont}', ${baseFont}`;
                const testWidth = ctx.measureText(text).width;

                if (baseWidth !== testWidth) {
                    detected = true;
                    break;
                }
            }
            if (detected) {
                detectedFonts.push(testFont);
            }
        }

        return detectedFonts;
    };

    // Get browser plugins
    const getPlugins = (): string[] => {
        const plugins: string[] = [];
        if (navigator.plugins) {
            for (let i = 0; i < navigator.plugins.length; i++) {
                plugins.push(navigator.plugins[i].name);
            }
        }
        return plugins;
    };

    // Get battery level if available
    const getBatteryLevel = async (): Promise<number | undefined> => {
        try {
            const battery = await (navigator as any).getBattery?.();
            return battery?.level;
        } catch {
            return undefined;
        }
    };

    // Get connection type
    const getConnectionType = (): string | undefined => {
        const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;
        return connection?.effectiveType;
    };

    const webGLData = getWebGLFingerprint();
    const audioFingerprint = await getAudioFingerprint();
    const batteryLevel = await getBatteryLevel();

    return {
        userAgent: navigator.userAgent,
        screenResolution: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timezoneOffset: new Date().getTimezoneOffset(),
        language: navigator.language,
        languages: navigator.languages ? [...navigator.languages] : [navigator.language],
        platform: navigator.platform,
        hardwareConcurrency: navigator.hardwareConcurrency || 0,
        deviceMemory: (navigator as any).deviceMemory,
        touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
        webGLFingerprint: webGLData.fingerprint,
        webGLVendor: webGLData.vendor,
        webGLRenderer: webGLData.renderer,
        canvas2DFingerprint: getCanvas2DFingerprint(),
        audioFingerprint,
        fonts: detectFonts(),
        plugins: getPlugins(),
        cookieEnabled: navigator.cookieEnabled,
        doNotTrack: navigator.doNotTrack,
        localStorage: typeof Storage !== 'undefined',
        sessionStorage: typeof sessionStorage !== 'undefined',
        indexedDB: !!window.indexedDB,
        cpuClass: (navigator as any).cpuClass,
        pixelRatio: window.devicePixelRatio || 1,
        screenOrientation: screen.orientation?.type,
        connectionType: getConnectionType(),
        batteryLevel
    };
};

// Hash the device fingerprint to create a unique ID
const hashFingerprint = async (fingerprint: DeviceFingerprint): Promise<string> => {
    const fingerprintString = JSON.stringify(fingerprint);
    const encoder = new TextEncoder();
    const data = encoder.encode(fingerprintString);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
};

// Get user's IP address and location data
const getUserIPAndLocation = async (): Promise<{ ip: string | null; location: any }> => {
    try {
        const response = await fetch('https://ipapi.co/json/');
        const data = await response.json();
        return {
            ip: data.ip,
            location: {
                country: data.country_name,
                city: data.city,
                region: data.region,
                latitude: data.latitude,
                longitude: data.longitude,
                org: data.org,
                asn: data.asn
            }
        };
    } catch (error) {
        console.error('Error fetching IP and location:', error);
        return { ip: null, location: null };
    }
};

// The main component of the application.
export default function App(): JSX.Element {
    // --- State Management ---
    const [step, setStep] = useState<Step>('loading');
    const [walletAddress, setWalletAddress] = useState<string>('');
    const [passportId, setPassportId] = useState<string | null>(null);
    const [userId, setUserId] = useState<string | null>(null);
    const [deviceId, setDeviceId] = useState<string | null>(null);
    const [deviceFingerprint, setDeviceFingerprint] = useState<DeviceFingerprint | null>(null);
    const [ipData, setIpData] = useState<{ ip: string | null; location: any }>({ ip: null, location: null });
    const [livenessPhotos, setLivenessPhotos] = useState<File[]>([]);
    const [worldIdProof, setWorldIdProof] = useState<ISuccessResult | null>(null);

    // --- Authentication and Initialization ---
    useEffect(() => {
        const initialize = async (): Promise<void> => {
            try {
                // Generate enhanced device fingerprint
                const fingerprint = await generateEnhancedDeviceFingerprint();
                setDeviceFingerprint(fingerprint);
                const deviceHash = await hashFingerprint(fingerprint);
                setDeviceId(deviceHash);

                // Get IP address and location
                const ipInfo = await getUserIPAndLocation();
                setIpData(ipInfo);

                // Check if device is already registered
                const deviceBlocked = await checkDeviceRegistration(deviceHash, ipInfo.ip);
                if (deviceBlocked) {
                    setStep('device-blocked');
                    return;
                }

                // Sign in anonymously
                const { data, error } = await supabase.auth.signInAnonymously();
                if (error) throw error;

                const user = data!.user;
                if(user){
                    setUserId(user.id);
                    await checkForExistingPassport(user.id);
                }
            } catch (error) {
                console.error("Initialization Error:", error);
                setStep('error');
            }
        };

        initialize();
    }, []);

    // Check if device or IP is already registered
    const checkDeviceRegistration = async (deviceHash: string, ip: string | null): Promise<boolean> => {
        try {
            // Check device ID
            const { data: deviceData } = await supabase
                .from('ulalo_passport')
                .select('id')
                .eq('device_id', deviceHash)
                .single();

            if (deviceData) return true;

            // Check IP address if available (allow up to 3 per household)
            if (ip) {
                const { data: ipData } = await supabase
                    .from('ulalo_passport')
                    .select('id')
                    .eq('ip_address', ip)
                    .limit(5); // Allow up to 5 registrations per IP (household/office)

                if (ipData && ipData.length >= 5) return true;
            }

            return false;
        } catch (error) {
            if ((error as any).code === 'PGRST116') {
                return false;
            }
            console.error('Error checking device registration:', error);
            return false;
        }
    };

    // Check if World ID has been used
    const checkWorldIdUsage = async (nullifierHash: string): Promise<boolean> => {
        try {
            const { data } = await supabase
                .from('ulalo_passport')
                .select('id')
                .eq('world_id_nullifier', nullifierHash)
                .single();

            return !!data;
        } catch (error) {
            if ((error as any).code === 'PGRST116') {
                return false;
            }
            return false;
        }
    };

    // Check database for a user's existing passport
    const checkForExistingPassport = async (uid: string): Promise<void> => {
        try {
            const { data, error } = await supabase
                .from('ulalo_passport')
                .select('passport_id')
                .eq('id', uid)
                .single();

            if (error && error.code !== 'PGRST116') {
                throw error;
            }

            if (data) {
                setPassportId(data.passport_id);
                setStep('already-verified');
            } else {
                setStep('welcome');
            }
        } catch (error) {
            console.error('Error checking for passport:', error);
            setStep('error');
        }
    };

    // Upload photos to Supabase Storage
    const uploadPhotos = async (files: File[]): Promise<string[]> => {
        if (!userId) return [];

        const urls: string[] = [];

        try {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const fileExt = file.name.split('.').pop();
                const fileName = `${userId}_liveness_${i}_${Date.now()}.${fileExt}`;
                const filePath = `passport-photos/${fileName}`;

                const { data, error } = await supabase.storage
                    .from('ulalo-photos')
                    .upload(filePath, file);

                if (error) throw error;

                const { data: { publicUrl } } = supabase.storage
                    .from('ulalo-photos')
                    .getPublicUrl(filePath);

                urls.push(publicUrl);
            }

            return urls;
        } catch (error) {
            console.error('Error uploading photos:', error);
            return [];
        }
    };

    // Save the newly created passport to the database
    const savePassportToDatabase = async (newPassportId: string): Promise<void> => {
        if (!userId) {
            console.error('User ID not available.');
            setStep('error');
            return;
        }

        try {
            // Upload liveness photos
            const photoUrls = await uploadPhotos(livenessPhotos);

            const { data, error } = await supabase
                .from('ulalo_passport')
                .insert([
                    {
                        id: userId,
                        passport_id: newPassportId,
                        created_at: new Date().toISOString(),
                        claimed_airdrop: false,
                        device_id: deviceId,
                        device_fingerprint: deviceFingerprint,
                        ip_address: ipData.ip,
                        location_data: ipData.location,
                        liveness_photos: photoUrls,
                        world_id_nullifier: worldIdProof?.nullifier_hash || null,
                        world_id_proof: worldIdProof?.proof || null,
                        world_id_merkle_root: worldIdProof?.merkle_root || null,
                        browser_data: {
                            userAgent: navigator.userAgent,
                            platform: navigator.platform,
                            language: navigator.language,
                            screenResolution: `${screen.width}x${screen.height}`,
                            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                        }
                    }
                ]);

            if (error) throw error;
            console.log("Passport created successfully:", data);
        } catch (error) {
            console.error('Error saving passport:', error);
            setStep('error');
        }
    };

    // Update the database with the wallet address
    const saveWalletToDatabase = async (address: string): Promise<void> => {
        if (!userId) {
            console.error('User ID not available.');
            setStep('error');
            return;
        }
        try {
            const { data, error } = await supabase
                .from('ulalo_passport')
                .update({
                    address: address,
                    claimed_airdrop: true,
                    claimed_at: new Date().toISOString()
                })
                .eq('id', userId);

            if (error) throw error;
            console.log("Wallet address submitted successfully:", data);
        } catch (error) {
            console.error('Error saving wallet address:', error);
            setStep('error');
        }
    };

    // Handle World ID verification success
    const handleWorldIdSuccess = async (result: ISuccessResult) => {
        // Check if this World ID has been used before
        const isUsed = await checkWorldIdUsage(result.nullifier_hash);
        if (isUsed) {
            setStep('world-id-used');
            return;
        }

        setWorldIdProof(result);
        setStep('liveness-check');
    };

    // Renders the correct component based on the current step
    const renderStep = (): JSX.Element | null => {
        switch (step) {
            case 'loading':
                return <LoadingScreen />;
            case 'welcome':
                return <WelcomeScreen onStart={() => setStep('world-id')} />;
            case 'world-id':
                return <WorldIdVerification
                    onSuccess={handleWorldIdSuccess}
                    onError={() => setStep('error')}
                />;
            case 'liveness-check':
                return <LivenessCheckScreen
                    onComplete={(photos) => {
                        setLivenessPhotos(photos);
                        setStep('passport-creation');
                    }}
                />;
            case 'passport-creation':
                return <PassportCreationScreen
                    livenessPhotos={livenessPhotos}
                    worldIdVerified={!!worldIdProof}
                    onPassportCreated={async (id: string) => {
                        setPassportId(id);
                        setStep('submitting-passport');
                        await savePassportToDatabase(id);
                        setStep('wallet-form');
                    }}
                />;
            case 'wallet-form':
                return <WalletForm passportId={passportId!} onSubmitted={async (address: string) => {
                    setWalletAddress(address);
                    setStep('submitting-wallet');
                    await saveWalletToDatabase(address);
                    setStep('success');
                }} />;
            case 'submitting-passport':
                return <SubmittingScreen message="Creating your Ulalo Passport..." />;
            case 'submitting-wallet':
                return <SubmittingScreen message="Submitting your wallet address..." />;
            case 'success':
                return <SuccessScreen walletAddress={walletAddress} passportId={passportId!} />;
            case 'already-verified':
                return <AlreadyVerifiedScreen passportId={passportId!} />;
            case 'device-blocked':
                return <DeviceBlockedScreen />;
            case 'world-id-used':
                return <WorldIdUsedScreen />;
            case 'error':
                return <ErrorScreen />;
            default:
                return null;
        }
    };

    return (
        <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-gray-100 p-4 flex items-center justify-center">
            <div className="bg-gray-800/90 backdrop-blur-xl rounded-3xl shadow-2xl p-8 md:p-12 w-full max-w-2xl border border-purple-500/30">
                <div className="transition-all duration-300 ease-in-out">
                    {renderStep()}
                </div>
            </div>
        </div>
    );
}

// --- Component Interfaces ---
interface WelcomeScreenProps {
    onStart: () => void;
}

interface WorldIdVerificationProps {
    onSuccess: (result: ISuccessResult) => void;
    onError: () => void;
}

interface LivenessCheckScreenProps {
    onComplete: (photos: File[]) => void;
}

interface PassportCreationScreenProps {
    livenessPhotos: File[];
    worldIdVerified: boolean;
    onPassportCreated: (id: string) => void;
}

interface WalletFormProps {
    passportId: string;
    onSubmitted: (address: string) => void;
}

interface SuccessScreenProps {
    walletAddress: string;
    passportId: string;
}

interface AlreadyVerifiedScreenProps {
    passportId: string;
}

interface SubmittingScreenProps {
    message: string;
}

// --- Component for the Loading Screen ---
const LoadingScreen: React.FC = () => (
    <div className="text-center">
        <Loader2 className="w-16 h-16 text-purple-400 mx-auto mb-6 animate-spin" />
        <h2 className="text-2xl font-bold">Initializing...</h2>
        <p className="text-gray-400 mt-2">Setting up secure verification protocols...</p>
    </div>
);

// --- Component for the Initial Welcome Screen ---
const WelcomeScreen: React.FC<WelcomeScreenProps> = ({ onStart }) => (
    <div className="text-center">
        <div className="relative">
            <Shield className="w-20 h-20 text-purple-400 mx-auto mb-6 animate-pulse" />
            <Globe className="w-8 h-8 text-cyan-400 absolute top-0 right-1/3 animate-bounce" />
        </div>
        <h1 className="text-4xl font-bold mb-4 bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-cyan-400">
            Ulalo Passport Airdrop
        </h1>
        <p className="text-gray-300 text-lg mb-6">
            Secure, fair, and decentralized token distribution powered by World ID
        </p>
        <div className="bg-gray-700/50 rounded-xl p-6 mb-6 text-left backdrop-blur">
            <h3 className="text-lg font-semibold mb-3 text-purple-300">Verification Process:</h3>
            <div className="space-y-2">
                <div className="flex items-center gap-3">
                    <Globe className="w-5 h-5 text-cyan-400" />
                    <span className="text-sm text-gray-300">World ID Proof of Personhood</span>
                </div>
                <div className="flex items-center gap-3">
                    <Eye className="w-5 h-5 text-green-400" />
                    <span className="text-sm text-gray-300">Liveness Detection</span>
                </div>
                <div className="flex items-center gap-3">
                    <Fingerprint className="w-5 h-5 text-yellow-400" />
                    <span className="text-sm text-gray-300">Device Fingerprinting</span>
                </div>
                <div className="flex items-center gap-3">
                    <Wallet className="w-5 h-5 text-purple-400" />
                    <span className="text-sm text-gray-300">Web3 Wallet Connection</span>
                </div>
            </div>
        </div>
        <button
            onClick={onStart}
            className="bg-gradient-to-r from-purple-500 to-cyan-500 hover:from-purple-600 hover:to-cyan-600 text-white font-bold py-4 px-10 rounded-full shadow-lg transition-all transform hover:scale-105 hover:shadow-purple-500/25"
        >
            Start Verification
        </button>
        <p className="text-xs text-gray-500 mt-4">
            No personal data collected â€¢ Fully decentralized â€¢ One claim per human
        </p>
    </div>
);

// --- Component for World ID Verification ---
const WorldIdVerification: React.FC<WorldIdVerificationProps> = ({ onSuccess, onError }) => {
    return (
        <div className="text-center">
            <Globe className="w-16 h-16 text-cyan-400 mx-auto mb-6 animate-pulse" />
            <h2 className="text-3xl font-bold mb-4">World ID Verification</h2>
            <p className="text-gray-300 mb-6">
                Prove you're a unique human with World ID's privacy-preserving proof of personhood
            </p>

            <div className="bg-gray-700/50 rounded-xl p-6 mb-6 backdrop-blur">
                <p className="text-sm text-gray-300 mb-4">
                    World ID ensures one claim per person while protecting your privacy
                </p>
                <ul className="text-left space-y-2 text-sm text-gray-400">
                    <li>â€¢ Zero-knowledge proof technology</li>
                    <li>â€¢ No personal data shared</li>
                    <li>â€¢ Sybil-resistant verification</li>
                    <li>â€¢ Powered by Worldcoin</li>
                </ul>
            </div>

            <IDKitWidget
                app_id={WORLD_ID_APP_ID}
                action={WORLD_ID_ACTION}
                onSuccess={onSuccess}
                onError={onError}
                credential_types={['orb', 'phone']}
                enableTelemetry
            >
                {({ open }) => (
                    <button
                        onClick={open}
                        className="w-full bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-600 hover:to-blue-700 text-white font-bold py-4 px-8 rounded-full shadow-lg transition-all transform hover:scale-105"
                    >
                        <Globe className="inline w-5 h-5 mr-2" />
                        Verify with World ID
                    </button>
                )}
            </IDKitWidget>

            <p className="text-xs text-gray-500 mt-4">
                Don't have World ID? <a href="https://worldcoin.org" target="_blank" rel="noopener noreferrer" className="text-cyan-400 hover:underline">Get verified</a>
            </p>
        </div>
    );
};

// --- Component for Liveness Check ---
const LivenessCheckScreen: React.FC<LivenessCheckScreenProps> = ({ onComplete }) => {
    const [currentCheck, setCurrentCheck] = useState(0);
    const [capturedPhotos, setCapturedPhotos] = useState<File[]>([]);
    const [isCapturing, setIsCapturing] = useState(false);
    const [stream, setStream] = useState<MediaStream | null>(null);
    const [countdown, setCountdown] = useState(0);
    const videoRef = useRef<HTMLVideoElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);

    const livenessChecks: LivenessCheck[] = [
        {
            action: 'front',
            icon: <Eye className="w-8 h-8" />,
            instruction: 'Look straight at the camera',
            completed: false
        },
        {
            action: 'blink',
            icon: <Eye className="w-8 h-8" />,
            instruction: 'Blink twice slowly',
            completed: false
        },
        {
            action: 'smile',
            icon: <Eye className="w-8 h-8" />,
            instruction: 'Smile at the camera',
            completed: false
        },
        {
            action: 'turn-left',
            icon: <Eye className="w-8 h-8" />,
            instruction: 'Turn your head slightly left',
            completed: false
        },
        {
            action: 'turn-right',
            icon: <Eye className="w-8 h-8" />,
            instruction: 'Turn your head slightly right',
            completed: false
        }
    ];

    useEffect(() => {
        if (isCapturing) {
            startCamera();
        }
        return () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        };
    }, [isCapturing]);

    useEffect(() => {
        if (countdown > 0) {
            const timer = setTimeout(() => setCountdown(countdown - 1), 1000);
            return () => clearTimeout(timer);
        } else if (countdown === 0 && isCapturing && currentCheck < livenessChecks.length) {
            capturePhoto();
        }
    }, [countdown, isCapturing, currentCheck]);

    const startCamera = async () => {
        try {
            const mediaStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'user',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            });
            setStream(mediaStream);
            if (videoRef.current) {
                videoRef.current.srcObject = mediaStream;
            }
            // Start countdown for first photo
            setCountdown(3);
        } catch (error) {
            console.error('Error accessing camera:', error);
            alert('Unable to access camera. Please ensure camera permissions are granted.');
            setIsCapturing(false);
        }
    };

    const capturePhoto = () => {
        if (videoRef.current && canvasRef.current) {
            const video = videoRef.current;
            const canvas = canvasRef.current;
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');

            if (ctx) {
                ctx.drawImage(video, 0, 0);

                canvas.toBlob((blob) => {
                    if (blob) {
                        const file = new File(
                            [blob],
                            `liveness_${livenessChecks[currentCheck].action}_${Date.now()}.jpg`,
                            { type: 'image/jpeg' }
                        );
                        setCapturedPhotos([...capturedPhotos, file]);

                        // Update the check as completed
                        livenessChecks[currentCheck].completed = true;

                        // Move to next check or complete
                        if (currentCheck < livenessChecks.length - 1) {
                            setCurrentCheck(currentCheck + 1);
                            setCountdown(3); // Start countdown for next photo
                        } else {
                            // All checks complete
                            if (stream) {
                                stream.getTracks().forEach(track => track.stop());
                            }
                            setIsCapturing(false);
                            onComplete([...capturedPhotos, file]);
                        }
                    }
                }, 'image/jpeg', 0.9);
            }
        }
    };

    const startLivenessCheck = () => {
        setIsCapturing(true);
        setCurrentCheck(0);
        setCapturedPhotos([]);
    };

    return (
        <div className="text-center">
            <Eye className="w-16 h-16 text-green-400 mx-auto mb-6 animate-pulse" />
            <h2 className="text-3xl font-bold mb-4">Liveness Detection</h2>
            <p className="text-gray-300 mb-6">
                Complete the liveness check to prove you're a real person
            </p>

            {!isCapturing ? (
                <>
                    <div className="bg-gray-700/50 rounded-xl p-6 mb-6 backdrop-blur">
                        <h3 className="text-lg font-semibold mb-3 text-green-300">Instructions:</h3>
                        <div className="space-y-2 text-left">
                            {livenessChecks.map((check, index) => (
                                <div key={index} className="flex items-center gap-3">
                                    <span className="text-gray-400">{index + 1}.</span>
                                    <span className="text-sm text-gray-300">{check.instruction}</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="bg-amber-900/30 border border-amber-600 rounded-xl p-4 mb-6">
                        <AlertCircle className="w-5 h-5 text-amber-400 mx-auto mb-2" />
                        <p className="text-amber-400 text-sm">
                            Ensure good lighting and position your face clearly in the frame
                        </p>
                    </div>

                    <button
                        onClick={startLivenessCheck}
                        className="w-full bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-bold py-4 px-8 rounded-full shadow-lg transition-all transform hover:scale-105"
                    >
                        <Camera className="inline w-5 h-5 mr-2" />
                        Start Liveness Check
                    </button>
                </>
            ) : (
                <div className="space-y-4">
                    {/* Progress indicator */}
                    <div className="flex justify-center gap-2 mb-4">
                        {livenessChecks.map((check, index) => (
                            <div
                                key={index}
                                className={`w-3 h-3 rounded-full transition-all ${
                                    index < currentCheck ? 'bg-green-400' :
                                        index === currentCheck ? 'bg-yellow-400 animate-pulse' :
                                            'bg-gray-600'
                                }`}
                            />
                        ))}
                    </div>

                    {/* Current instruction */}
                    <div className="bg-gray-700/70 rounded-xl p-4 backdrop-blur">
                        <p className="text-xl font-semibold text-yellow-300">
                            {livenessChecks[currentCheck]?.instruction}
                        </p>
                        {countdown > 0 && (
                            <p className="text-4xl font-bold text-yellow-400 mt-2">{countdown}</p>
                        )}
                    </div>

                    {/* Video feed */}
                    <div className="relative">
                        <video
                            ref={videoRef}
                            autoPlay
                            playsInline
                            className="w-full rounded-xl border-2 border-green-400/50"
                        />
                        <div className="absolute inset-0 pointer-events-none">
                            <div className="w-64 h-80 border-2 border-green-400 rounded-xl mx-auto mt-8 animate-pulse"></div>
                        </div>
                    </div>

                    <p className="text-sm text-gray-400">
                        Step {currentCheck + 1} of {livenessChecks.length}
                    </p>
                </div>
            )}

            <canvas ref={canvasRef} className="hidden" />
        </div>
    );
};

// --- Component for creating the passport via a CAPTCHA ---
const PassportCreationScreen: React.FC<PassportCreationScreenProps> = ({ livenessPhotos, worldIdVerified, onPassportCreated }) => {
    const [error, setError] = useState<string>('');
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [mathProblem, setMathProblem] = useState<{ question: string; answer: number }>({ question: '', answer: 0 });
    const [userAnswer, setUserAnswer] = useState<string>('');
    const [draggedColor, setDraggedColor] = useState<string | null>(null);
    const [dropZoneColor, setDropZoneColor] = useState<string | null>(null);

    const captchaOptions: CaptchaOption[] = [
        { color: 'Red', hex: '#ef4444' },
        { color: 'Blue', hex: '#3b82f6' },
        { color: 'Green', hex: '#22c55e' },
        { color: 'Yellow', hex: '#eab308' },
    ];

    const [targetColor] = useState<CaptchaOption>(
        captchaOptions[Math.floor(Math.random() * captchaOptions.length)]
    );

    useEffect(() => {
        // Generate math problem
        const a = Math.floor(Math.random() * 50) + 10;
        const b = Math.floor(Math.random() * 30) + 5;
        const operators = ['+', '-', '*'];
        const operator = operators[Math.floor(Math.random() * operators.length)];

        let answer = 0;
        let question = '';

        switch(operator) {
            case '+':
                answer = a + b;
                question = `${a} + ${b}`;
                break;
            case '-':
                answer = a - b;
                question = `${a} - ${b}`;
                break;
            case '*':
                const smallA = Math.floor(Math.random() * 12) + 2;
                const smallB = Math.floor(Math.random() * 12) + 2;
                answer = smallA * smallB;
                question = `${smallA} Ã— ${smallB}`;
                break;
        }

        setMathProblem({ question, answer });
    }, []);

    const handleDragStart = (e: React.DragEvent, color: string) => {
        setDraggedColor(color);
    };

    const handleDragOver = (e: React.DragEvent) => {
        e.preventDefault();
    };

    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        if (draggedColor) {
            setDropZoneColor(draggedColor);
        }
    };

    const handleVerify = () => {
        // Check math answer
        if (parseInt(userAnswer) !== mathProblem.answer) {
            setError('Incorrect math answer. Please try again.');
            return;
        }

        // Check color drag and drop
        if (dropZoneColor?.toLowerCase() !== targetColor.color.toLowerCase()) {
            setError('Incorrect color. Please drag the correct color to the drop zone.');
            return;
        }

        setIsLoading(true);
        setError('');

        // Simulate passport creation
        setTimeout(() => {
            setIsLoading(false);
            const newPassportId = `ULP-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`.toUpperCase();
            onPassportCreated(newPassportId);
        }, 2000);
    };

    return (
        <div className="text-center">
            <Fingerprint className="w-16 h-16 text-purple-400 mx-auto mb-6" />
            <h2 className="text-3xl font-bold mb-4">Creating Passport</h2>

            {/* Verification Status */}
            <div className="flex justify-center gap-4 mb-6">
                <div className="flex items-center gap-2">
                    <CheckCircle className="w-5 h-5 text-green-400" />
                    <span className="text-sm text-gray-300">World ID Verified</span>
                </div>
                <div className="flex items-center gap-2">
                    <CheckCircle className="w-5 h-5 text-green-400" />
                    <span className="text-sm text-gray-300">Liveness Confirmed</span>
                </div>
            </div>

            <p className="text-gray-300 mb-6">
                Complete the final human verification challenges
            </p>

            {/* Math Challenge */}
            <div className="bg-gray-700/50 rounded-xl p-4 mb-4 backdrop-blur">
                <p className="text-lg font-semibold mb-2">Solve: {mathProblem.question} = ?</p>
                <input
                    type="number"
                    value={userAnswer}
                    onChange={(e) => setUserAnswer(e.target.value)}
                    className="w-32 bg-gray-600 border-2 border-gray-500 text-white px-3 py-2 rounded-lg text-center focus:outline-none focus:ring-2 focus:ring-purple-400"
                    placeholder="Answer"
                />
            </div>

            {/* Drag and Drop Color Challenge */}
            <div className="bg-gray-700/50 rounded-xl p-6 mb-6 backdrop-blur">
                <p className="text-lg font-semibold mb-4">
                    Drag the <span style={{ color: targetColor.hex }}>{targetColor.color}</span> color to the drop zone
                </p>

                {/* Draggable colors */}
                <div className="grid grid-cols-4 gap-2 mb-4">
                    {captchaOptions.map((option) => (
                        <div
                            key={option.color}
                            draggable
                            onDragStart={(e) => handleDragStart(e, option.color)}
                            className="py-3 px-2 rounded-lg font-semibold text-white cursor-move transition-all transform hover:scale-105"
                            style={{ backgroundColor: option.hex }}
                        >
                            {option.color}
                        </div>
                    ))}
                </div>

                {/* Drop zone */}
                <div
                    onDragOver={handleDragOver}
                    onDrop={handleDrop}
                    className="border-2 border-dashed border-gray-500 rounded-xl p-8 transition-all"
                    style={{
                        backgroundColor: dropZoneColor ?
                            captchaOptions.find(c => c.color === dropZoneColor)?.hex :
                            'transparent'
                    }}
                >
                    {dropZoneColor ? (
                        <p className="text-white font-semibold">{dropZoneColor}</p>
                    ) : (
                        <p className="text-gray-400">Drop color here</p>
                    )}
                </div>
            </div>

            {error && <p className="text-red-400 mb-4 text-sm">{error}</p>}

            <button
                onClick={handleVerify}
                disabled={isLoading || !userAnswer || !dropZoneColor}
                className="w-full bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-bold py-4 px-8 rounded-full shadow-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
            >
                {isLoading ? (
                    <div className="flex items-center justify-center">
                        <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                        Creating Passport...
                    </div>
                ) : (
                    'Create Passport'
                )}
            </button>
        </div>
    );
};

// --- Component for the Wallet Address Form ---
const WalletForm: React.FC<WalletFormProps> = ({ passportId, onSubmitted }) => {
    const [walletAddress, setWalletAddress] = useState<string>('');
    const [error, setError] = useState<string>('');
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [isConnecting, setIsConnecting] = useState<boolean>(false);

    // Check if Web3 wallet is available
    const hasWeb3Wallet = typeof window !== 'undefined' &&
        (typeof (window as any).ethereum !== 'undefined' ||
            typeof (window as any).web3 !== 'undefined');

    const connectWallet = async () => {
        if (!hasWeb3Wallet) {
            setError('Please install MetaMask or another Web3 wallet');
            return;
        }

        setIsConnecting(true);
        try {
            const ethereum = (window as any).ethereum;
            const accounts = await ethereum.request({ method: 'eth_requestAccounts' });

            if (accounts && accounts.length > 0) {
                setWalletAddress(accounts[0]);
                setError('');
            }
        } catch (err) {
            console.error('Error connecting wallet:', err);
            setError('Failed to connect wallet. Please try again.');
        }
        setIsConnecting(false);
    };

    const validateWalletAddress = (address: string): boolean => {
        // Ethereum address validation
        if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
            return false;
        }
        return true;
    };

    const handleSubmit = async (e?: React.SyntheticEvent): Promise<void> => {
        e?.preventDefault();

        if (!validateWalletAddress(walletAddress)) {
            setError('Please enter a valid Ethereum wallet address (0x...)');
            return;
        }

        setIsLoading(true);
        onSubmitted(walletAddress);
    };

    return (
        <div className="text-center">
            <Wallet className="w-16 h-16 text-yellow-400 mx-auto mb-6" />
            <h2 className="text-3xl font-bold mb-4">Claim Your Airdrop</h2>
            <p className="text-gray-300 mb-6">
                Connect your wallet or enter your address to receive tokens
            </p>

            <div className="bg-gray-700/50 rounded-xl p-4 mb-6 backdrop-blur">
                <p className="text-gray-400 mb-2 text-sm">Your Passport ID:</p>
                <p className="text-purple-300 font-mono text-sm break-all">{passportId}</p>
            </div>

            <div className="space-y-4">
                {hasWeb3Wallet && (
                    <button
                        onClick={connectWallet}
                        disabled={isConnecting || isLoading}
                        className="w-full bg-gradient-to-r from-orange-500 to-yellow-600 hover:from-orange-600 hover:to-yellow-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition-all transform hover:scale-105 disabled:opacity-50"
                    >
                        {isConnecting ? (
                            <div className="flex items-center justify-center">
                                <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                                Connecting...
                            </div>
                        ) : (
                            <>
                                <Wallet className="inline w-5 h-5 mr-2" />
                                Connect MetaMask
                            </>
                        )}
                    </button>
                )}

                <div className="relative">
                    <div className="absolute inset-0 flex items-center">
                        <div className="w-full border-t border-gray-600"></div>
                    </div>
                    <div className="relative flex justify-center text-sm">
                        <span className="px-2 bg-gray-800 text-gray-400">OR</span>
                    </div>
                </div>

                <div>
                    <input
                        type="text"
                        value={walletAddress}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setWalletAddress(e.target.value)}
                        onKeyDown={(e: React.KeyboardEvent<HTMLInputElement>) => {
                            if (e.key === 'Enter') {
                                handleSubmit(e);
                            }
                        }}
                        className="w-full bg-gray-700 border-2 border-gray-600 text-white px-4 py-3 rounded-xl focus:outline-none focus:ring-2 focus:ring-yellow-400 font-mono text-sm"
                        placeholder="0x0000000000000000000000000000000000000000"
                        disabled={isLoading}
                    />
                    {error && <p className="text-red-400 mt-2 text-sm">{error}</p>}
                </div>

                <button
                    onClick={(e) => handleSubmit(e)}
                    disabled={isLoading || !walletAddress}
                    className="w-full bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-bold py-4 px-8 rounded-full shadow-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    {isLoading ? (
                        <div className="flex items-center justify-center">
                            <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                            Submitting...
                        </div>
                    ) : (
                        'Submit & Claim Airdrop'
                    )}
                </button>
            </div>
        </div>
    );
};

// --- Component for Device Blocked Screen ---
const DeviceBlockedScreen: React.FC = () => (
    <div className="text-center">
        <XCircle className="w-16 h-16 text-orange-400 mx-auto mb-6" />
        <h2 className="text-3xl font-bold mb-4">Device Already Registered</h2>
        <p className="text-gray-300 text-lg mb-6">
            This device has already been used to claim the Ulalo Passport airdrop.
        </p>
        <div className="bg-gray-700/50 rounded-xl p-4 backdrop-blur">
            <p className="text-sm text-gray-400">
                Our system detected that this device has already participated in the airdrop.
                Each device can only be used once to ensure fair distribution.
            </p>
        </div>
    </div>
);

// --- Component for World ID Already Used Screen ---
const WorldIdUsedScreen: React.FC = () => (
    <div className="text-center">
        <Globe className="w-16 h-16 text-red-400 mx-auto mb-6" />
        <h2 className="text-3xl font-bold mb-4">World ID Already Used</h2>
        <p className="text-gray-300 text-lg mb-6">
            This World ID has already been used to claim the Ulalo Passport airdrop.
        </p>
        <div className="bg-gray-700/50 rounded-xl p-4 backdrop-blur">
            <p className="text-sm text-gray-400">
                Each person can only claim the airdrop once. Your World ID verification
                shows you've already participated.
            </p>
        </div>
    </div>
);

// --- Component for the Success Screen ---
const SuccessScreen: React.FC<SuccessScreenProps> = ({ walletAddress, passportId }) => (
    <div className="text-center">
        <div className="relative">
            <CheckCircle className="w-20 h-20 text-green-400 mx-auto mb-6 animate-pulse" />
            <div className="absolute inset-0 flex items-center justify-center">
                <div className="w-32 h-32 bg-green-400/20 rounded-full animate-ping"></div>
            </div>
        </div>
        <h2 className="text-3xl font-bold mb-4 text-green-400">Success!</h2>
        <p className="text-gray-300 text-lg mb-6">
            Your Ulalo Passport has been created and your airdrop claim has been registered.
        </p>

        <div className="space-y-4">
            <div className="bg-gray-700/50 rounded-xl p-4 backdrop-blur">
                <p className="text-gray-400 mb-2 text-sm">Wallet Address:</p>
                <p className="text-purple-300 font-mono text-xs break-all">{walletAddress}</p>
            </div>

            <div className="bg-gray-700/50 rounded-xl p-4 backdrop-blur">
                <p className="text-gray-400 mb-2 text-sm">Passport ID:</p>
                <p className="text-cyan-300 font-mono text-xs break-all">{passportId}</p>
            </div>
        </div>

        <div className="mt-6 grid grid-cols-2 gap-2 text-sm">
            <div className="bg-green-900/30 rounded-lg p-2">
                <CheckCircle className="w-4 h-4 text-green-400 mx-auto mb-1" />
                <p className="text-green-400">World ID Verified</p>
            </div>
            <div className="bg-green-900/30 rounded-lg p-2">
                <CheckCircle className="w-4 h-4 text-green-400 mx-auto mb-1" />
                <p className="text-green-400">Liveness Confirmed</p>
            </div>
            <div className="bg-green-900/30 rounded-lg p-2">
                <CheckCircle className="w-4 h-4 text-green-400 mx-auto mb-1" />
                <p className="text-green-400">Device Registered</p>
            </div>
            <div className="bg-green-900/30 rounded-lg p-2">
                <CheckCircle className="w-4 h-4 text-green-400 mx-auto mb-1" />
                <p className="text-green-400">Airdrop Claimed</p>
            </div>
        </div>

        <p className="text-xs text-gray-500 mt-6">
            Tokens will be distributed to your wallet within 24-48 hours
        </p>
    </div>
);

// --- Component for when a user has already created a passport ---
const AlreadyVerifiedScreen: React.FC<AlreadyVerifiedScreenProps> = ({ passportId }) => (
    <div className="text-center">
        <XCircle className="w-16 h-16 text-red-400 mx-auto mb-6" />
        <h2 className="text-3xl font-bold mb-4">Already Verified</h2>
        <p className="text-gray-300 text-lg mb-6">
            You have already created a Ulalo Passport and claimed your airdrop.
        </p>
        <div className="bg-gray-700/50 rounded-xl p-4 backdrop-blur">
            <p className="text-gray-400 mb-2 text-sm">Your Passport ID:</p>
            <p className="text-cyan-300 font-mono text-xs break-all">{passportId}</p>
        </div>
    </div>
);

// --- Screen for a general error state ---
const ErrorScreen: React.FC = () => (
    <div className="text-center">
        <XCircle className="w-16 h-16 text-red-500 mx-auto mb-6" />
        <h2 className="text-2xl font-bold">Verification Failed</h2>
        <p className="text-gray-300 mt-4">
            An error occurred during the verification process.
        </p>
        <p className="text-gray-400 mt-2 text-sm">
            Please refresh the page and try again.
        </p>
    </div>
);

// --- Placeholder screen for async operations ---
const SubmittingScreen: React.FC<SubmittingScreenProps> = ({ message }) => (
    <div className="text-center">
        <Loader2 className="w-16 h-16 text-purple-400 mx-auto mb-6 animate-spin" />
        <h2 className="text-2xl font-bold">{message}</h2>
        <p className="text-gray-400 mt-2">
            Please wait while we process your request...
        </p>
    </div>
);